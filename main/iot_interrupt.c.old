#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "iot_globals.h"
#include "iot_defines.h"

#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/task.h"

#include "driver/gpio.h"
#include "driver/gpio_filter.h"
#include "iot_interrupt.h"

#include "hal/gpio_ll.h"
#include "esp_sleep.h"
#include "esp_log.h"
//#include "log.h"
//#include "mqtt.h"



static void iot_gpio_isr_handler(void* arg);
static void iot_gpio_control_task(void *params);


static void iot_gpio_isr_handler(void* arg)
{
    //ESP_LOGI(TAG, "GPIO ISR triggered");
    uint32_t gpio_num = (uint32_t) arg;
    xQueueSendFromISR(simpleSwitchInreQueue, &gpio_num, NULL);
}

static void iot_gpio_control_task(void *params)
{
    //iot_isr_params_s* pParams = (iot_isr_params_s*) params;
    //struct iot_isr_params_s* isrParamsPtr = malloc(sizeof(iot_isr_params_t));
    iot_intr_switch_simple_config_t *isrParamsParams = malloc(sizeof(iot_intr_switch_simple_config_t*));
    isrParamsParams = (iot_intr_switch_simple_config_t*) params;
    iot_intr_switch_simple_config_t isrParams; // = malloc(sizeof(iot_isr_params_t));
    while (true)
    {
        //ESP_LOGD(TAG, "%i\t%i\t%i\t%s\t%s\t%s", intrParams.intrPin, intrParams.outPin, intrParams.outInvert, intrParams.mqttSubTopic, intrParams.mqttDataHigh, intrParams.mqttDataLow);
        // Call the intr task handler function, passing all params
        if (xQueueReceive(simpleSwitchInreQueue, &isrParams, portMAX_DELAY)) {
            //ESP_LOGD(TAG, "%i\t%i\t%i\t%s\t%s\t%s", intrParams.intrPin, intrParams.outPin, intrParams.outInvert, intrParams.mqttSubTopic, intrParams.mqttDataHigh, intrParams.mqttDataLow);
            //ESP_LOGI(TAG, "Params passed from 'iot_gpio_intr_pin' -- intrPin: %i\toutPin: %i\tParam: %i", intrParams->intrPin, intrParams->outPin, (int)intrParams);
            //uint32_t level = intrParams->outInvert ? !gpio_get_level(intrParams->intrPin) : gpio_get_level(intrParams->intrPin);
            ESP_LOGI(TAG, "%i", isrParamsParams->outPin);
            gpio_set_level(GPIO_NUM_1, !gpio_get_level(GPIO_NUM_0));
        }
    }
}

void iot_conf_controller(iot_config_linked_list_t* configList) {
    while(true) {
        iot_config_item_t* configItem = configList->configEntry;
        switch(configItem->configItemType) {
            case IOT_CONFIG_SIMPLE_SWITCH :
                iot_intr_simple_switch_setup((iot_intr_switch_simple_config_t*)(configItem->configItem));   
                break;

            case IOT_CONFIG_DUMMY_TEST :
                break;
                iot_intr_simple_switch_setup((iot_intr_switch_simple_config_t*)(configItem->configItem));   
                break;
        }
        if(configList->next == NULL) {
            break;
        }
        configList = configList->next;
    }
}

esp_err_t iot_intr_simple_switch_setup(iot_intr_switch_simple_config_t* intrConfig)

{
    // Confiure pins.

    // Pretty sure there is a better way. But for now, it works.
    bool intrPullUp = ((intrConfig->intrPull == 0) || (intrConfig->intrPull == 2)) ? true : false;
    bool intrPullDown = ((intrConfig->intrPull == 1) || (intrConfig->intrPull == 2)) ? true : false;
    bool outPullUp = ((intrConfig->outPull == 0) || (intrConfig->intrPull == 2)) ? true : false;
    bool outPullDown = ((intrConfig->outPull == 1) || (intrConfig->intrPull == 2)) ? true : false;



    gpio_config_t intrPinConfig = {
        .pin_bit_mask = BIT64(intrConfig->intrPin),
        .mode = GPIO_MODE_INPUT,
        .pull_down_en = intrPullDown,
        .pull_up_en = intrPullUp,
        .intr_type = intrConfig->intrType,
    };
    ESP_ERROR_CHECK(gpio_config(&intrPinConfig));

    if (intrConfig->outPin != GPIO_NUM_NC) {
        gpio_config_t outPinConfig = {
            .pin_bit_mask = BIT64(intrConfig->outPin),
            .mode = GPIO_MODE_OUTPUT,
            .pull_down_en = outPullDown,
            .pull_up_en = outPullUp,
            .intr_type = GPIO_MODE_DEF_DISABLE,
        };
        ESP_ERROR_CHECK(gpio_config(&outPinConfig));
    }


    // Configure GLitch Filter on interrupt pin.

    gpio_pin_glitch_filter_config_t* glitchFilterConfig = malloc(sizeof(gpio_pin_glitch_filter_config_t));
    glitchFilterConfig->clk_src = 4; // SOC_MOD_CLK_PLL_F80M
    glitchFilterConfig->gpio_num = intrConfig->intrPin;
    gpio_glitch_filter_handle_t* glitchFilter = malloc(sizeof(gpio_glitch_filter_handle_t));
    ESP_ERROR_CHECK(gpio_new_pin_glitch_filter(glitchFilterConfig, glitchFilter));
    ESP_ERROR_CHECK(gpio_glitch_filter_enable(*glitchFilter));

    // Configure the interrupt
    BaseType_t xReturned = xTaskCreate(&iot_gpio_control_task, intrConfig->intrTaskName, 1024, intrConfig, 1, NULL);
    if(xReturned == pdPASS) {
        ESP_LOGI(TAG, "Interrupt Task in FreeRTOS created.");
    } else {
        ESP_LOGE(TAG, "Interrupt Task in FreeRTOS creation FAILED.");
    }
    
    ESP_ERROR_CHECK(gpio_isr_handler_add(intrConfig->intrPin, iot_gpio_isr_handler, &(intrConfig->intrPin)));

    return ESP_OK;


}

